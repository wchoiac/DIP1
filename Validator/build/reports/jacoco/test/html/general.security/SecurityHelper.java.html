<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ko"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SecurityHelper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DIP1</a> &gt; <a href="index.source.html" class="el_package">general.security</a> &gt; <span class="el_source">SecurityHelper.java</span></div><h1>SecurityHelper.java</h1><pre class="source lang-java linenums">package general.security;

import config.Configuration;
import general.utility.GeneralHelper;
import org.bouncycastle.asn1.ASN1ObjectIdentifier;
import org.bouncycastle.asn1.ASN1OctetString;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.DERSequence;
import org.bouncycastle.asn1.x500.RDN;
import org.bouncycastle.asn1.x500.X500Name;
import org.bouncycastle.asn1.x500.style.BCStyle;
import org.bouncycastle.asn1.x500.style.IETFUtils;
import org.bouncycastle.asn1.x509.*;
import org.bouncycastle.asn1.x509.Extension;
import org.bouncycastle.cert.X509v3CertificateBuilder;
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter;
import org.bouncycastle.cert.jcajce.JcaX509CertificateHolder;
import org.bouncycastle.crypto.digests.SHA256Digest;
import org.bouncycastle.crypto.params.ECDomainParameters;
import org.bouncycastle.crypto.params.ECPrivateKeyParameters;
import org.bouncycastle.crypto.params.ECPublicKeyParameters;
import org.bouncycastle.crypto.signers.ECDSASigner;
import org.bouncycastle.crypto.signers.HMacDSAKCalculator;
import org.bouncycastle.jce.ECNamedCurveTable;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.jce.spec.ECParameterSpec;
import org.bouncycastle.jce.spec.ECPublicKeySpec;
import org.bouncycastle.math.ec.ECCurve;
import org.bouncycastle.math.ec.ECPoint;
import org.bouncycastle.operator.OperatorCreationException;
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;
import org.bouncycastle.util.io.pem.PemObject;
import org.bouncycastle.util.io.pem.PemReader;
import org.bouncycastle.util.io.pem.PemWriter;

import javax.crypto.KeyGenerator;
import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.*;
import java.math.BigInteger;
import java.net.InetAddress;
import java.security.*;
import java.security.cert.Certificate;
import java.security.cert.*;
import java.security.interfaces.ECPrivateKey;
import java.security.interfaces.ECPublicKey;
import java.security.spec.*;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.Random;


<span class="nc" id="L59">public class SecurityHelper {</span>


    static {
<span class="fc" id="L63">        Security.addProvider(new BouncyCastleProvider());</span>
    }

<span class="fc" id="L66">    static final Random random = new SecureRandom();</span>

    //----------------------------------------------for pseudo random function start------------------------------------------------

    // use HmacSHA256 for algo
    // key - randomly generated master key , content - timestamp
    public static SecretKey aesKeyWithHMACPRF(byte[] key, byte[] content, String hmacAlgo) throws NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException {
<span class="nc" id="L73">        SecretKeySpec secretKeySpecForHMACPRF = new SecretKeySpec(key, hmacAlgo); // it means key would be used for such algorithm (i.e. HmacSHA256 in this case)</span>
<span class="nc" id="L74">        Mac mac = Mac.getInstance(hmacAlgo); // it means MAC algorithm is algo (i.e. HmacSHA256 in this case)</span>
<span class="nc" id="L75">        mac.init(secretKeySpecForHMACPRF);</span>
<span class="nc" id="L76">        SecretKeySpec aesKeySpec = new SecretKeySpec(mac.doFinal(content), &quot;AES&quot;);</span>

<span class="nc" id="L78">        return SecretKeyFactory.getInstance(&quot;AES&quot;).generateSecret(aesKeySpec);</span>

    }

    //----------------------------------------------for pseudo random function end------------------------------------------------


    //----------------------------------------------for hash start------------------------------------------------

    public static byte[] hash(byte[] data, String algo) throws NoSuchAlgorithmException {
<span class="fc" id="L88">        MessageDigest digest = MessageDigest.getInstance(algo);</span>
<span class="fc" id="L89">        return digest.digest(data);</span>

    }

    //----------------------------------------------for hash end------------------------------------------------

    //----------------------------------------------for file handling start------------------------------------------------
    public static void writePublicKeyToPEM(PublicKey publicKey, String fileName) throws IOException {
<span class="nc" id="L97">        Writer writer = new FileWriter(fileName);</span>
<span class="nc" id="L98">        PemWriter pemWriter = new PemWriter(writer);</span>
<span class="nc" id="L99">        pemWriter.writeObject(new PemObject(&quot;PUBLIC KEY&quot;, publicKey.getEncoded()));</span>
<span class="nc" id="L100">        pemWriter.close();</span>
<span class="nc" id="L101">    }</span>

    //referece: https://www.programcreek.com/java-api-examples/?api=org.bouncycastle.util.io.pem.PemReader
    public static PublicKey getPublicKeyFromPEM(String fileName, String algo) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {
<span class="nc" id="L105">        FileReader reader = new FileReader(fileName);</span>
<span class="nc" id="L106">        PemReader pemReader = new PemReader(reader);</span>
<span class="nc" id="L107">        KeyFactory keyFactory = KeyFactory.getInstance(algo);</span>
<span class="nc" id="L108">        byte[] content = pemReader.readPemObject().getContent();</span>
<span class="nc" id="L109">        pemReader.close();</span>

<span class="nc" id="L111">        return keyFactory.generatePublic(new X509EncodedKeySpec(content));</span>
    }

    public static void writePrivateKeyToPEM(PrivateKey privateKey, String fileName, String algo) throws IOException {
<span class="nc" id="L115">        Writer writer = new FileWriter(fileName);</span>
<span class="nc" id="L116">        PemWriter pemWriter = new PemWriter(writer);</span>
<span class="nc" id="L117">        pemWriter.writeObject(new PemObject(algo + &quot; PRIVATE KEY&quot;, privateKey.getEncoded()));</span>
<span class="nc" id="L118">        pemWriter.close();</span>
<span class="nc" id="L119">    }</span>

    public static PrivateKey getPrivateFromPEM(String fileName, String algo) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {
<span class="nc" id="L122">        FileReader reader = new FileReader(fileName);</span>
<span class="nc" id="L123">        PemReader pemReader = new PemReader(reader);</span>
<span class="nc" id="L124">        KeyFactory keyFactory = KeyFactory.getInstance(algo);</span>
<span class="nc" id="L125">        byte[] content = pemReader.readPemObject().getContent();</span>
<span class="nc" id="L126">        pemReader.close();</span>
<span class="nc" id="L127">        return keyFactory.generatePrivate(new PKCS8EncodedKeySpec(content));</span>
    }

    public static void writeX509ToDER(X509Certificate cert, File file) throws IOException, CertificateEncodingException {
<span class="nc" id="L131">        FileOutputStream fos = new FileOutputStream(file);</span>
<span class="nc" id="L132">        fos.write(cert.getEncoded());</span>
<span class="nc" id="L133">        fos.close();</span>
<span class="nc" id="L134">    }</span>

    public static X509Certificate getX509FromDER(File file) throws IOException, CertificateException {
<span class="nc" id="L137">        CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X509&quot;);</span>
<span class="nc" id="L138">        FileInputStream fis = new FileInputStream(file);</span>
<span class="nc" id="L139">        ByteArrayInputStream bis = new ByteArrayInputStream(fis.readAllBytes());</span>
<span class="nc" id="L140">        X509Certificate cert = (X509Certificate) certificateFactory.generateCertificate(bis);</span>

<span class="nc" id="L142">        bis.close();</span>

<span class="nc" id="L144">        return cert;</span>
    }
    //----------------------------------------------for file handling end------------------------------------------------

    //----------------------------------------------for certificate start------------------------------------------------
    public static String getSubjectCNFromX509Certificate(X509Certificate cert) throws CertificateEncodingException {
<span class="nc" id="L150">        X500Name x500name = new JcaX509CertificateHolder(cert).getSubject();</span>
<span class="nc" id="L151">        RDN cn = x500name.getRDNs(BCStyle.CN)[0];</span>
<span class="nc" id="L152">        return IETFUtils.valueToString(cn.getFirst().getValue());</span>
    }

    public static String getIssuerCNFromX509Certificate(X509Certificate cert) throws CertificateEncodingException {
<span class="nc" id="L156">        X500Name x500name = new JcaX509CertificateHolder(cert).getIssuer();</span>
<span class="nc" id="L157">        RDN cn = x500name.getRDNs(BCStyle.CN)[0];</span>
<span class="nc" id="L158">        return IETFUtils.valueToString(cn.getFirst().getValue());</span>
    }

    //referece: https://www.programcreek.com/java-api-examples/?api=org.bouncycastle.util.io.pem.PemReader
    public static X509Certificate getX509FromBytes(byte[] bytes) throws IOException, CertificateException {
<span class="nc" id="L163">        CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X509&quot;);</span>
<span class="nc" id="L164">        ByteArrayInputStream bis = new ByteArrayInputStream(bytes);</span>
<span class="nc" id="L165">        X509Certificate cert = (X509Certificate) certificateFactory.generateCertificate(bis);</span>
<span class="nc" id="L166">        bis.close();</span>

<span class="nc" id="L168">        return cert;</span>
    }


    //reference: https://stackoverflow.com/questions/16412315/creating-custom-x509-v3-extensions-in-java-with-bouncy-castle
    public static X509Certificate issueCertificate(PublicKey newPublicKey, ECPublicKey issuerPublicKey, PrivateKey issuerPrivateKey, Date noAfter, String subjectName, String authorityName
            , byte[] subjectKeyIdentifierBytes, byte[] authorityKeyIdentifierBytes, InetAddress ipAddress, String algo, boolean isForSigning) throws CertificateException, OperatorCreationException, IOException {
<span class="nc" id="L175">        X509v3CertificateBuilder builder = new X509v3CertificateBuilder(</span>
                new X500Name(&quot;CN=&quot; + authorityName),
<span class="nc" id="L177">                BigInteger.valueOf(new Random().nextInt()),</span>
                new Date(),
                noAfter,
                new X500Name(&quot;CN=&quot; + subjectName),
<span class="nc" id="L181">                SubjectPublicKeyInfo.getInstance(newPublicKey.getEncoded()));</span>

<span class="nc" id="L183">        AuthorityKeyIdentifier authorityKeyIdentifier = new AuthorityKeyIdentifier(authorityKeyIdentifierBytes);</span>
<span class="nc" id="L184">        builder.addExtension(Extension.authorityKeyIdentifier, false, authorityKeyIdentifier);</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">        if (isForSigning) {</span>
<span class="nc" id="L186">            SubjectKeyIdentifier subjectKeyIdentifier = new SubjectKeyIdentifier(subjectKeyIdentifierBytes);</span>
<span class="nc" id="L187">            builder.addExtension(Extension.subjectKeyIdentifier, false, subjectKeyIdentifier);</span>
        }

<span class="nc bnc" id="L190" title="All 2 branches missed.">        if (isForSigning) {</span>
<span class="nc" id="L191">            KeyUsage usage = new KeyUsage(KeyUsage.keyCertSign | KeyUsage.digitalSignature);</span>
<span class="nc" id="L192">            builder.addExtension(Extension.keyUsage, false, usage.getEncoded());</span>
<span class="nc" id="L193">        } else {</span>
<span class="nc" id="L194">            KeyUsage usage = new KeyUsage(KeyUsage.digitalSignature);</span>
<span class="nc" id="L195">            builder.addExtension(Extension.keyUsage, false, usage.getEncoded());</span>
        }

<span class="nc bnc" id="L198" title="All 2 branches missed.">        if (ipAddress != null) {</span>
<span class="nc" id="L199">            GeneralName[] generalName = {new GeneralName(GeneralName.iPAddress, ipAddress.getHostAddress())};</span>
<span class="nc" id="L200">            builder.addExtension(Extension.subjectAlternativeName, false, new DERSequence(generalName));</span>
        }

<span class="nc" id="L203">        X509Certificate cert = new JcaX509CertificateConverter().getCertificate(builder</span>
<span class="nc" id="L204">                .build(new JcaContentSignerBuilder(algo).setProvider(&quot;BC&quot;).</span>
<span class="nc" id="L205">                        build(issuerPrivateKey)));</span>


<span class="nc" id="L208">        return cert;</span>

    }


    public static byte[] getIssuerIdentifierFromX509Cert(X509Certificate cert) {
<span class="nc" id="L214">        byte[] bytes = cert.getExtensionValue(Extension.authorityKeyIdentifier.getId());</span>
<span class="nc" id="L215">        byte[] octets = ASN1OctetString.getInstance(bytes).getOctets();</span>
<span class="nc" id="L216">        AuthorityKeyIdentifier authorityKeyIdentifier = AuthorityKeyIdentifier.getInstance(octets);</span>
<span class="nc" id="L217">        return authorityKeyIdentifier.getKeyIdentifier();</span>
    }

    //----------------------------------------------for certificate end------------------------------------------------

    //----------------------------------------------for api start------------------------------------------------

    // reference: https://www.baeldung.com/java-password-hashing
    public static byte[] passwordHash(char[] password, byte[] salt, String algo) throws NoSuchAlgorithmException {
<span class="nc" id="L226">        KeySpec spec = new PBEKeySpec(password, salt, 65536, Configuration.PASSWORD_HASH_LENGTH * 8);</span>
<span class="nc" id="L227">        SecretKeyFactory factory = SecretKeyFactory.getInstance(algo);</span>

<span class="nc" id="L229">        byte[] result = null;</span>
        try {
<span class="nc" id="L231">            result = factory.generateSecret(spec).getEncoded();</span>
<span class="nc" id="L232">        } catch (InvalidKeySpecException e) {</span>
<span class="nc" id="L233">            e.printStackTrace(); // not expected</span>
<span class="nc" id="L234">        }</span>
<span class="nc" id="L235">        return result;</span>
    }

    public static String generateSecureToken() {
<span class="nc" id="L239">        return GeneralHelper.bytesToBase64UrlString(new BigInteger(130, random).toByteArray());</span>
    }

    //----------------------------------------------for api end------------------------------------------------

    //----------------------------------------------for key start------------------------------------------------

    public static KeyPair generateECKeyPair(String curve) throws NoSuchAlgorithmException, InvalidAlgorithmParameterException {
<span class="fc" id="L247">        Security.addProvider(new BouncyCastleProvider());</span>
<span class="fc" id="L248">        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(&quot;EC&quot;);</span>
<span class="fc" id="L249">        keyGen.initialize(new ECGenParameterSpec(curve), new SecureRandom());</span>
<span class="fc" id="L250">        KeyPair pair = keyGen.generateKeyPair();</span>
<span class="fc" id="L251">        return pair;</span>
    }

    //reference: https://stackoverflow.com/questions/5127379/how-to-generate-a-rsa-keypair-with-a-privatekey-encrypted-with-password
    public static KeyPair generateRSAKeyPair() throws NoSuchAlgorithmException {
<span class="nc" id="L256">        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(&quot;RSA&quot;);</span>
<span class="nc" id="L257">        keyGen.initialize(2048);</span>
<span class="nc" id="L258">        KeyPair pair = keyGen.generateKeyPair();</span>
<span class="nc" id="L259">        return pair;</span>
    }


    //https://stackoverflow.com/questions/33218674/how-to-make-a-bouncy-castle-ecpublickey
    public static byte[] getCompressedRawECPublicKey(ECPublicKey publicKey, String curveName) {

<span class="fc" id="L266">        BigInteger affineX = publicKey.getW().getAffineX();</span>
<span class="fc" id="L267">        BigInteger affineY = publicKey.getW().getAffineY();</span>
<span class="fc" id="L268">        ECCurve curve = ECNamedCurveTable.getParameterSpec(curveName).getCurve();</span>

<span class="fc" id="L270">        return curve.createPoint(affineX, affineY).getEncoded(true);</span>
    }

    //https://bitcoin.stackexchange.com/questions/44024/get-uncompressed-public-key-from-compressed-form
    public static ECPublicKey getECPublicKeyFromCompressedRaw(byte[] raw, String curveName) throws InvalidKeySpecException {
<span class="nc" id="L275">        ECParameterSpec parameterSpec = ECNamedCurveTable.getParameterSpec(curveName);</span>
<span class="nc" id="L276">        ECPoint point = parameterSpec.getCurve().decodePoint(raw);</span>

        try {
<span class="nc" id="L279">            return (ECPublicKey) KeyFactory.getInstance(&quot;EC&quot;).generatePublic(new ECPublicKeySpec(point, parameterSpec));</span>
<span class="nc" id="L280">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L281">            e.printStackTrace();</span>
        }
<span class="nc" id="L283">        return null; // not expected</span>
    }

    //https://bitcoin.stackexchange.com/questions/44024/get-uncompressed-public-key-from-compressed-form
    public static ECPublicKey getECPublicKeyFromEncoded(byte[] encoded) throws InvalidKeySpecException {


<span class="nc" id="L290">        KeyFactory keyFactory = null;</span>
        try {
<span class="nc" id="L292">            keyFactory = KeyFactory.getInstance(&quot;EC&quot;);</span>
<span class="nc" id="L293">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L294">            e.printStackTrace();// not expected</span>
<span class="nc" id="L295">        }</span>
<span class="nc" id="L296">        return (ECPublicKey) keyFactory.generatePublic(new X509EncodedKeySpec(encoded));</span>
    }

    public static boolean checkCurve(byte[] ecPublicKeyEncoded, ASN1ObjectIdentifier curveOID) {
<span class="nc" id="L300">        SubjectPublicKeyInfo subjectPublicKeyInfo = SubjectPublicKeyInfo.getInstance(ASN1Sequence.getInstance(ecPublicKeyEncoded));</span>
<span class="nc" id="L301">        ASN1ObjectIdentifier oid = (ASN1ObjectIdentifier) subjectPublicKeyInfo.getAlgorithm().getParameters();</span>
<span class="nc" id="L302">        return oid.equals(curveOID);</span>
    }

    //----------------------------------------------for key end------------------------------------------------

    //----------------------------------------------for signature start------------------------------------------------

    //reference: http://www.java2s.com/Tutorial/Java/0490__Security/SimpleDigitalSignatureExample.htm
    public static boolean verifyDEREncodedSignature(PublicKey signerPublicKey, byte[] signature, byte[] content, String algo) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException {
<span class="nc" id="L311">        boolean valid = false;</span>
<span class="nc" id="L312">        Signature sig = Signature.getInstance(algo);</span>
<span class="nc" id="L313">        sig.initVerify(signerPublicKey);</span>
<span class="nc" id="L314">        sig.update(content);</span>
<span class="nc" id="L315">        valid = sig.verify(signature);</span>

<span class="nc" id="L317">        return valid;</span>
    }


    public static byte[] createDEREncodedSignature(PrivateKey signerPrivateKey, byte[] content, String algo) throws SignatureException, InvalidKeyException, NoSuchAlgorithmException {

<span class="nc" id="L323">        Signature sig = Signature.getInstance(algo);</span>
<span class="nc" id="L324">        sig.initSign(signerPrivateKey);</span>
<span class="nc" id="L325">        sig.update(content);</span>

<span class="nc" id="L327">        return sig.sign();</span>

    }


    // SHA256withECDSA implementation
    // input content unlike createRawECDSASignatureWithHash - automatically hashes
    public static boolean verifyRawECDSASignatureWithContent(ECPublicKey signerPublicKey, byte[] content, byte[] signature, String hashAlgo, String curveName) throws NoSuchAlgorithmException {

<span class="fc" id="L336">        byte[] hash = hash(content, hashAlgo);</span>

<span class="fc" id="L338">        byte[] r = Arrays.copyOfRange(signature, 0, signature.length / 2);</span>
<span class="fc" id="L339">        byte[] s = Arrays.copyOfRange(signature, signature.length / 2, signature.length);</span>

<span class="fc" id="L341">        ECParameterSpec ecParameterSpec = ECNamedCurveTable.getParameterSpec(curveName);</span>
<span class="fc" id="L342">        BigInteger affineX = signerPublicKey.getW().getAffineX();</span>
<span class="fc" id="L343">        BigInteger affineY = signerPublicKey.getW().getAffineY();</span>
<span class="fc" id="L344">        ECCurve curve = ecParameterSpec.getCurve();</span>

<span class="fc" id="L346">        ECDomainParameters domainParameters = new ECDomainParameters(curve, ecParameterSpec.getG(), ecParameterSpec.getN(), ecParameterSpec.getH());</span>
<span class="fc" id="L347">        ECPublicKeyParameters publicKeyParameters = new ECPublicKeyParameters(curve.createPoint(affineX, affineY), domainParameters);</span>

<span class="fc" id="L349">        ECDSASigner ecdsaSigner = new ECDSASigner(new HMacDSAKCalculator(new SHA256Digest()));</span>
<span class="fc" id="L350">        ecdsaSigner.init(false, publicKeyParameters);</span>

<span class="fc" id="L352">        return ecdsaSigner.verifySignature(hash, new BigInteger(1, r), new BigInteger(1, s));</span>

    }


    // SHA256withECDSA implementation
    // input content unlike createRawECDSASignatureWithHash - automatically hashes
    public static byte[] createRawECDSASignatureWithContent(ECPrivateKey signerPrivateKey, byte[] content, String hashAlgo, String curveName, int coordinateLength) throws NoSuchAlgorithmException {

<span class="fc" id="L361">        byte[] hash = hash(content, hashAlgo);</span>
<span class="fc" id="L362">        ECParameterSpec ecParameterSpec = ECNamedCurveTable.getParameterSpec(curveName);</span>
<span class="fc" id="L363">        ECCurve curve = ecParameterSpec.getCurve();</span>
<span class="fc" id="L364">        ECDomainParameters domainParameters = new ECDomainParameters(curve, ecParameterSpec.getG(), ecParameterSpec.getN(), ecParameterSpec.getH());</span>
<span class="fc" id="L365">        ECPrivateKeyParameters privateKeyParameters = new ECPrivateKeyParameters(signerPrivateKey.getS(), domainParameters);</span>

<span class="fc" id="L367">        ECDSASigner ecdsaSigner = new ECDSASigner(new HMacDSAKCalculator(new SHA256Digest()));</span>
<span class="fc" id="L368">        ecdsaSigner.init(true, privateKeyParameters);</span>

<span class="fc" id="L370">        BigInteger[] bigIntegers = ecdsaSigner.generateSignature(hash);</span>

<span class="fc" id="L372">        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</span>
        try {
            // for adjusting length so that each point is 32 byte (pad or remove leading zero)
<span class="fc bfc" id="L375" title="All 2 branches covered.">            for (BigInteger bigInteger : bigIntegers) {</span>
<span class="fc" id="L376">                byte[] tempBytes = bigInteger.toByteArray();</span>
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">                if (tempBytes.length &lt; coordinateLength) {</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">                    for (int i = 0; i &lt; coordinateLength - tempBytes.length; ++i)</span>
<span class="nc" id="L379">                        byteArrayOutputStream.write(0);</span>
<span class="nc" id="L380">                    byteArrayOutputStream.write(tempBytes);</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">                } else if (tempBytes.length == coordinateLength) {</span>
<span class="fc" id="L382">                    byteArrayOutputStream.write(tempBytes);</span>
                } else {//leading zero
<span class="fc" id="L384">                    byteArrayOutputStream.write(tempBytes, tempBytes.length - coordinateLength, coordinateLength);</span>
                }

            }
<span class="nc" id="L388">        } catch (IOException e) {</span>
<span class="nc" id="L389">            e.printStackTrace();</span>
<span class="fc" id="L390">        }</span>

<span class="fc" id="L392">        return byteArrayOutputStream.toByteArray();</span>

    }

    // NONEwithECDSA implementation
    // input &quot;hash&quot; not the content
    public static byte[] createRawECDSASignatureWithHash(ECPrivateKey signerPrivateKey, byte[] hash, String curveName, int coordinateLength) {

<span class="nc" id="L400">        ECParameterSpec ecParameterSpec = ECNamedCurveTable.getParameterSpec(curveName);</span>
<span class="nc" id="L401">        ECCurve curve = ecParameterSpec.getCurve();</span>
<span class="nc" id="L402">        ECDomainParameters domainParameters = new ECDomainParameters(curve, ecParameterSpec.getG(), ecParameterSpec.getN(), ecParameterSpec.getH());</span>
<span class="nc" id="L403">        ECPrivateKeyParameters privateKeyParameters = new ECPrivateKeyParameters(signerPrivateKey.getS(), domainParameters);</span>

<span class="nc" id="L405">        ECDSASigner ecdsaSigner = new ECDSASigner(new HMacDSAKCalculator(new SHA256Digest()));</span>
<span class="nc" id="L406">        ecdsaSigner.init(true, privateKeyParameters);</span>

<span class="nc" id="L408">        BigInteger[] bigIntegers = ecdsaSigner.generateSignature(hash);</span>

<span class="nc" id="L410">        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</span>
        try {
            // for adjusting length so that each point is 32 byte (pad or remove leading zero)
<span class="nc bnc" id="L413" title="All 2 branches missed.">            for (BigInteger bigInteger : bigIntegers) {</span>
<span class="nc" id="L414">                byte[] tempBytes = bigInteger.toByteArray();</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">                if (tempBytes.length &lt; coordinateLength) {</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">                    for (int i = 0; i &lt; coordinateLength - tempBytes.length; ++i)</span>
<span class="nc" id="L417">                        byteArrayOutputStream.write(0);</span>
<span class="nc" id="L418">                    byteArrayOutputStream.write(tempBytes);</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">                } else if (tempBytes.length == coordinateLength) {</span>
<span class="nc" id="L420">                    byteArrayOutputStream.write(tempBytes);</span>
                } else {//leading zero
<span class="nc" id="L422">                    byteArrayOutputStream.write(tempBytes, tempBytes.length - coordinateLength, coordinateLength);</span>
                }

            }
<span class="nc" id="L426">        } catch (IOException e) {</span>
<span class="nc" id="L427">            e.printStackTrace();</span>
<span class="nc" id="L428">        }</span>

<span class="nc" id="L430">        return byteArrayOutputStream.toByteArray();</span>

    }


    //test reference:https://stackoverflow.com/questions/49825455/ecdsa-signature-java-vs-go
    public static byte[] getRawFromDERECDSASignature(byte[] signature, int coordinateLength) {

<span class="nc" id="L438">        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</span>

<span class="nc bnc" id="L440" title="All 2 branches missed.">        int startR = (signature[1] &amp; 0x80) != 0 ? 3 : 2;</span>
<span class="nc" id="L441">        int lengthR = signature[startR + 1];</span>

<span class="nc" id="L443">        int startS = startR + 2 + lengthR;</span>
<span class="nc" id="L444">        int lengthS = signature[startS + 1];</span>

        try {
<span class="nc bnc" id="L447" title="All 2 branches missed.">            if (lengthR &lt; coordinateLength) {</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">                for (int i = 0; i &lt; coordinateLength - lengthR; ++i)</span>
<span class="nc" id="L449">                    byteArrayOutputStream.write(0);</span>
<span class="nc" id="L450">                byteArrayOutputStream.write(Arrays.copyOfRange(signature, startR + 2, startR + 2 + lengthR));</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">            } else if (lengthR == coordinateLength) {</span>
<span class="nc" id="L452">                byteArrayOutputStream.write(Arrays.copyOfRange(signature, startR + 2, startR + 2 + lengthR));</span>
            } else {//leading zero
<span class="nc" id="L454">                byteArrayOutputStream.write(Arrays.copyOfRange(signature, startR + 2 + lengthR - coordinateLength, startR + 2 + lengthR));</span>
            }

<span class="nc bnc" id="L457" title="All 2 branches missed.">            if (lengthS &lt; coordinateLength) {</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">                for (int i = 0; i &lt; coordinateLength - lengthS; ++i)</span>
<span class="nc" id="L459">                    byteArrayOutputStream.write(0);</span>
<span class="nc" id="L460">                byteArrayOutputStream.write(Arrays.copyOfRange(signature, startS + 2, startS + 2 + lengthS));</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">            } else if (lengthS == coordinateLength) {</span>
<span class="nc" id="L462">                byteArrayOutputStream.write(Arrays.copyOfRange(signature, startS + 2, startS + 2 + lengthS));</span>
            } else {//leading zero
<span class="nc" id="L464">                byteArrayOutputStream.write(Arrays.copyOfRange(signature, startS + 2 + lengthS - coordinateLength, startS + 2 + lengthS));</span>
            }
<span class="nc" id="L466">        } catch (IOException e) {</span>
<span class="nc" id="L467">            e.printStackTrace();</span>
<span class="nc" id="L468">        }</span>

<span class="nc" id="L470">        return byteArrayOutputStream.toByteArray();</span>
    }

    public static byte[] rawToDERECDSASignature(byte[] raw) // points are expected to have the same length
    {
<span class="nc" id="L475">        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</span>
<span class="nc" id="L476">        int pointLength = raw.length / 2;</span>
        try {
<span class="nc" id="L478">            byteArrayOutputStream.write(0x30); // sequence</span>
<span class="nc" id="L479">            byteArrayOutputStream.write(2 * pointLength + 4); // length</span>
<span class="nc" id="L480">            byteArrayOutputStream.write(0x02); // integer</span>
<span class="nc" id="L481">            byteArrayOutputStream.write(pointLength); // point length</span>
<span class="nc" id="L482">            byteArrayOutputStream.write(Arrays.copyOfRange(raw, 0, pointLength));</span>
<span class="nc" id="L483">            byteArrayOutputStream.write(0x02);</span>
<span class="nc" id="L484">            byteArrayOutputStream.write(pointLength);</span>
<span class="nc" id="L485">            byteArrayOutputStream.write(Arrays.copyOfRange(raw, pointLength, raw.length));</span>

<span class="nc" id="L487">        } catch (IOException e) {</span>
<span class="nc" id="L488">            e.printStackTrace();</span>
<span class="nc" id="L489">        }</span>

<span class="nc" id="L491">        return byteArrayOutputStream.toByteArray();</span>
    }
    //----------------------------------------------for signature end------------------------------------------------

    //reference: https://stackoverflow.com/questions/16412315/creating-custom-x509-v3-extensions-in-java-with-bouncy-castle
    public static X509Certificate selfSignCertOnlyForPatientKeyStore(PublicKey selfPublicKey, PrivateKey selfPrivateKey, String algo) throws CertificateException, OperatorCreationException, ParseException {
<span class="nc" id="L497">        DateFormat formatter = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span>

<span class="nc" id="L499">        X509v3CertificateBuilder builder = new X509v3CertificateBuilder(</span>
                new X500Name(&quot;CN=&quot; + &quot;patient&quot;),
<span class="nc" id="L501">                BigInteger.valueOf(new Random().nextInt()),</span>
                new Date(),
<span class="nc" id="L503">                formatter.parse(&quot;9999-12-31&quot;),</span>
                new X500Name(&quot;CN=&quot; + &quot;patient&quot;),
<span class="nc" id="L505">                SubjectPublicKeyInfo.getInstance(selfPublicKey.getEncoded()));</span>


<span class="nc" id="L508">        X509Certificate cert = new JcaX509CertificateConverter().getCertificate(builder</span>
<span class="nc" id="L509">                .build(new JcaContentSignerBuilder(algo).setProvider(&quot;BC&quot;).</span>
<span class="nc" id="L510">                        build(selfPrivateKey)));</span>


<span class="nc" id="L513">        return cert;</span>

    }
    public static void keyStoreTest() throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, NoSuchProviderException, IOException, CertificateException, KeyStoreException, UnrecoverableEntryException, ParseException, OperatorCreationException, InvalidKeySpecException, InvalidKeyException {


        // =============================== PREPARATION START=========================
        //password (could be PIN)
<span class="nc" id="L521">        char[] keyStorePassword = new char[]{'a', 'b', 'c'}; // for storing keystore</span>
<span class="nc" id="L522">        char[] keyPairEntryPassword = new char[]{'a', 'b', 'c'}; // could be same as keystore password for user convenience</span>
<span class="nc" id="L523">        char[] masterKeyEntryPassword = new char[]{'a', 'b', 'c'}; // could be same as keystore password for user convenience</span>
        // alias
<span class="nc" id="L525">        String keyPairAlias =&quot;DIP1-PATIENT-KEYPAIR&quot;;</span>
<span class="nc" id="L526">        String masterKeyAlias =&quot;DIP1-PATIENT-MASTERKEY&quot;;</span>

        // create keypair, self signed certificate and AES key(for random value(master key) purpose)
<span class="nc" id="L529">        KeyPair keyPair = generateECKeyPair(Configuration.ELIPTIC_CURVE);</span>
<span class="nc" id="L530">        ECPublicKey ecPublicKey = (ECPublicKey) keyPair.getPublic();</span>
<span class="nc" id="L531">        ECPrivateKey ecPrivateKey = (ECPrivateKey) keyPair.getPrivate();</span>

<span class="nc" id="L533">        X509Certificate selfSignCert =selfSignCertOnlyForPatientKeyStore(ecPublicKey, ecPrivateKey, Configuration.BLOCKCHAIN_SIGNATURE_ALGORITHM);</span>

<span class="nc" id="L535">        KeyGenerator keyGen = KeyGenerator.getInstance(&quot;AES&quot;);</span>
<span class="nc" id="L536">        keyGen.init(256);</span>
<span class="nc" id="L537">        SecretKey masterKey = keyGen.generateKey();</span>

        // =============================== PREPARATION END=========================

        //==================================== STORE START===================================
        // create empty pkcs12 keystore
<span class="nc" id="L543">        KeyStore keyStore = KeyStore.getInstance(&quot;pkcs12&quot;);</span>
<span class="nc" id="L544">        keyStore.load(null);</span>

        // store keypair
<span class="nc" id="L547">        keyStore.setKeyEntry(keyPairAlias, ecPrivateKey, keyPairEntryPassword</span>
                , new Certificate[]{selfSignCert});

        // store master key (AES key)
<span class="nc" id="L551">        KeyStore.SecretKeyEntry masterKeyEntry = new KeyStore.SecretKeyEntry(masterKey);</span>
<span class="nc" id="L552">        KeyStore.ProtectionParameter protParam = new KeyStore.PasswordProtection(masterKeyEntryPassword);</span>
<span class="nc" id="L553">        keyStore.setEntry(masterKeyAlias,masterKeyEntry,protParam);</span>

        //store keystore as byte array
<span class="nc" id="L556">        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</span>
<span class="nc" id="L557">        keyStore.store(byteArrayOutputStream, keyStorePassword); // for storing keystore</span>
<span class="nc" id="L558">        byte[] keyStoreFileByteArray = byteArrayOutputStream.toByteArray();</span>


        //==================================== STORE END===================================

        //==================================== LOAD START===================================
        // pkcs12 keystore from byte array
<span class="nc" id="L565">        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(keyStoreFileByteArray);</span>
<span class="nc" id="L566">        KeyStore loadedKeyStore = KeyStore.getInstance(&quot;pkcs12&quot;);</span>
<span class="nc" id="L567">        loadedKeyStore.load(byteArrayInputStream, keyStorePassword);</span>

        // load keypair
<span class="nc" id="L570">        KeyStore.PrivateKeyEntry keyPairEntry = (KeyStore.PrivateKeyEntry) loadedKeyStore.getEntry(keyPairAlias, new KeyStore.PasswordProtection(keyPairEntryPassword));</span>

<span class="nc" id="L572">        ECPublicKey loadedECPublicKey = (ECPublicKey) keyPairEntry.getCertificate().getPublicKey();</span>
<span class="nc" id="L573">        ECPrivateKey loadedECPrivateKey = (ECPrivateKey) keyPairEntry.getPrivateKey();</span>

        //load master key (AES key)
<span class="nc" id="L576">        KeyStore.SecretKeyEntry secretKeyEntry = (KeyStore.SecretKeyEntry) loadedKeyStore.getEntry(masterKeyAlias, new KeyStore.PasswordProtection(masterKeyEntryPassword));</span>
<span class="nc" id="L577">        SecretKey loadedMasterKey =secretKeyEntry.getSecretKey();</span>

        //==================================== LOAD END===================================


        //verification
<span class="nc" id="L583">        System.out.println(loadedECPublicKey.equals(ecPublicKey));</span>
<span class="nc" id="L584">        System.out.println(loadedECPrivateKey.equals(ecPrivateKey));</span>
<span class="nc" id="L585">        System.out.println(loadedMasterKey.equals(masterKey));</span>

        // to note, using psuedo random function for creating new AES key using master key with timestamp
<span class="nc" id="L588">        SecretKey aesForEncryption = aesKeyWithHMACPRF(masterKey.getEncoded(),GeneralHelper.longToBytes(System.currentTimeMillis()),&quot;HmacSHA256&quot;);</span>
<span class="nc" id="L589">        System.out.println(GeneralHelper.bytesToStringHex(aesForEncryption.getEncoded()));</span>

<span class="nc" id="L591">    }</span>

    public static void main(String[] args) throws Exception {

//        KeyPair keyPair = generateECKeyPair(Configuration.ELIPTIC_CURVE);
//        ECPrivateKey privateKey = (ECPrivateKey) keyPair.getPrivate();
//        byte[] hash = hash(new byte[]{0}, Configuration.BLOCKCHAIN_HASH_ALGORITHM);
//        byte[] sig = createRawECDSASignatureWithHash(privateKey, hash, Configuration.ELIPTIC_CURVE, Configuration.ELIPTIC_CURVE_COORDINATE_LENGTH);
//        byte[] sig2 = createRawECDSASignatureWithContent(privateKey, new byte[]{0}, &quot;SHA256&quot;, Configuration.ELIPTIC_CURVE, Configuration.ELIPTIC_CURVE_COORDINATE_LENGTH);
//        byte[] sig3 = createDEREncodedSignature(privateKey, new byte[]{0}, &quot;SHA256withECDSA&quot;);
//        byte[] sig4 = createDEREncodedSignature(privateKey, hash, &quot;NONEWithECDSA&quot;); // &lt;= client-side hashing
//        System.out.println(GeneralHelper.bytesToStringHex(sig));
//        System.out.println(GeneralHelper.bytesToStringHex(sig2));
//        System.out.println(GeneralHelper.bytesToStringHex(sig3));
//        System.out.println(GeneralHelper.bytesToStringHex(sig4));
//
//        byte[] extractedSig = getRawFromDERECDSASignature(sig3, Configuration.ELIPTIC_CURVE_COORDINATE_LENGTH);
//        System.out.println(GeneralHelper.bytesToStringHex(extractedSig));
//
//
//        System.out.println(verifyRawECDSASignatureWithContent((ECPublicKey) keyPair.getPublic(), new byte[]{0}, sig, &quot;SHA256&quot;, Configuration.ELIPTIC_CURVE));
//        System.out.println(verifyRawECDSASignatureWithContent((ECPublicKey) keyPair.getPublic(), new byte[]{0}, extractedSig, &quot;SHA256&quot;, Configuration.ELIPTIC_CURVE));
//        System.out.println(verifyDEREncodedSignature(keyPair.getPublic(), sig3, new byte[]{0}, &quot;SHA256withECDSA&quot;));
//        System.out.println(verifyDEREncodedSignature(keyPair.getPublic(), sig4, new byte[]{0}, &quot;SHA256withECDSA&quot;));
//
//
//        byte[] derSig3 = rawToDERECDSASignature(extractedSig);
//        System.out.println(GeneralHelper.bytesToStringHex(derSig3));
//        System.out.println(verifyDEREncodedSignature(keyPair.getPublic(), derSig3, new byte[]{0}, &quot;SHA256withECDSA&quot;));
//        // SHA256withECDSA for EC &amp; SHA256withRSA for RSA
//        //For now, just convert the byte values of the content into string (May be changed later)
//
//        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
//        System.out.println(GeneralHelper.bytesToStringHex(byteArrayOutputStream.toByteArray()));
//        byte[] hash2 = hash(byteArrayOutputStream.toByteArray(), Configuration.BLOCKCHAIN_HASH_ALGORITHM);
//        System.out.println((byte) ((1 &lt;&lt; Configuration.INITIAL_AUTHORITIES_BIT_POSITION)));

//        KeyPair keyPair = generateECKeyPair(Configuration.ELIPTIC_CURVE);
//        ECPrivateKey privateKey = (ECPrivateKey) keyPair.getPrivate();
//        byte[] content =new byte[]{1,2,3,4};
//        byte[] hash = hash(new byte[]{1,2,3,4}, Configuration.BLOCKCHAIN_HASH_ALGORITHM);
//        byte[] sig = createDEREncodedSignature(privateKey, hash, &quot;NONEWithECDSA&quot;); // &lt;= client-side hashing
//        System.out.println(verifyDEREncodedSignature(keyPair.getPublic(), sig, content, &quot;SHA256withECDSA&quot;));


//        System.out.println(GeneralHelper.bytesToStringHex(aesKeyWithHMACPRF(&quot;patient Master Key - it should be long enough for example 256 bit&quot;.getBytes()
//                ,GeneralHelper.longToBytes(System.currentTimeMillis()),&quot;HmacSHA256&quot;).getEncoded()));
//
//        KeyPair keyPair = generateECKeyPair(Configuration.ELIPTIC_CURVE);
//        System.out.println(DerivePubKeyFromPrivKey((ECPrivateKey) keyPair.getPrivate()).equals(keyPair.getPublic()));

<span class="nc" id="L642">        keyStoreTest();</span>

<span class="nc" id="L644">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>