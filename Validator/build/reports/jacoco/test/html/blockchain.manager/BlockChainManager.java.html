<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ko"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BlockChainManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DIP1</a> &gt; <a href="index.source.html" class="el_package">blockchain.manager</a> &gt; <span class="el_source">BlockChainManager.java</span></div><h1>BlockChainManager.java</h1><pre class="source lang-java linenums">package blockchain.manager;

import blockchain.Status;
import blockchain.block.*;
import blockchain.block.transaction.Transaction;
import exception.BlockChainObjectParsingException;
import blockchain.internal.*;
import config.Configuration;
import exception.FileCorruptionException;
import general.security.SecurityHelper;
import general.utility.GeneralHelper;

import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.util.*;


<span class="nc" id="L18">public class BlockChainManager {</span>

    //return total score, -1 if invalid
    // check for received header list(received from header request)
    public static int checkBlockHeaders(BlockHeader[] headers) throws IOException, BlockChainObjectParsingException {

<span class="nc bnc" id="L24" title="All 4 branches missed.">        if(headers==null||headers.length==0)</span>
<span class="nc" id="L25">            return -1;</span>


<span class="nc" id="L28">        byte[] initPrevBlockHash = headers[0].getPrevHash();</span>
<span class="nc" id="L29">        StateInfo initPrevBlockStateInfo = StateInfoManager.load(headers[0].getPrevHash());</span>
<span class="nc" id="L30">        BlockHeader initPrevBlockHeader = BlockManager.loadBlockHeader(headers[0].getPrevHash());</span>

<span class="nc bnc" id="L32" title="All 2 branches missed.">        if (initPrevBlockStateInfo==null) {</span>
<span class="nc" id="L33">            return -1;</span>
        }

<span class="nc" id="L36">        TreeMap&lt;byte[], AuthorityInfoForInternal&gt; tempAuthorityList = new TreeMap&lt;&gt;(new GeneralHelper.byteArrayComparator());</span>
<span class="nc" id="L37">        ArrayList&lt;byte[]&gt; tempOverallAuthorityList = AuthorityInfoManager.loadOverall(initPrevBlockHash);</span>
<span class="nc" id="L38">        ArrayList&lt;Voting&gt; tempVotingList = VotingManager.load(initPrevBlockHash);</span>

<span class="nc" id="L40">        int tempTotalScore= initPrevBlockStateInfo.getTotalScore();</span>
<span class="nc" id="L41">        long prevBlockTimeStemp = initPrevBlockHeader.getTimestamp();</span>

<span class="nc bnc" id="L43" title="All 2 branches missed.">        for(BlockHeader header: headers)</span>
        {
<span class="nc" id="L45">            int tempValidationInterval = tempOverallAuthorityList.size()/2 +1;</span>
<span class="nc" id="L46">            int index = GeneralHelper.getIndexFromArrayList(header.getValidatorIdentifier(),tempOverallAuthorityList);</span>
<span class="nc bnc" id="L47" title="All 2 branches missed.">            if(index==-1)</span>
<span class="nc" id="L48">                return -1;</span>
            else {
<span class="nc bnc" id="L50" title="All 2 branches missed.">                if (!tempAuthorityList.containsKey(header.getValidatorIdentifier())) {</span>

<span class="nc" id="L52">                    AuthorityInfoForInternal authorityInfoForInternal = AuthorityInfoManager.load(initPrevBlockHash, header.getValidatorIdentifier());</span>
<span class="nc" id="L53">                    tempAuthorityList.put(header.getValidatorIdentifier(), authorityInfoForInternal);</span>
                }
            }


<span class="nc" id="L58">            AuthorityInfoForInternal validatorInfoForInternal = tempAuthorityList.get(header.getValidatorIdentifier());</span>

            try {
<span class="nc bnc" id="L61" title="All 2 branches missed.">                if(!SecurityHelper.verifyRawECDSASignatureWithContent(validatorInfoForInternal.getAuthorityInfo().getPublicKey(), header.getSignatureCoverage(),header.getValidatorSignature(), Configuration.BLOCKCHAIN_HASH_ALGORITHM,Configuration.ELIPTIC_CURVE))</span>
<span class="nc" id="L62">                    return -1;</span>
<span class="nc" id="L63">            } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L64">                e.printStackTrace();</span>
<span class="nc" id="L65">            }</span>


            //=&gt; skip contentHash check

<span class="nc bnc" id="L70" title="All 2 branches missed.">            if(!validatorInfoForInternal.canSign(header.getBlockNumber(),tempOverallAuthorityList.size()))</span>
<span class="nc" id="L71">                return -1;</span>


<span class="nc" id="L74">            boolean isInOrder = AuthorityInfoForInternal.isInOrder(header.getBlockNumber(),tempOverallAuthorityList.size(), index);</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">            int expectedScore = isInOrder?2:1;</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">            if(expectedScore!= header.getScore())</span>
<span class="nc" id="L77">                return -1;</span>

<span class="nc bnc" id="L79" title="All 4 branches missed.">            if(header.getTimestamp() -prevBlockTimeStemp&lt;(isInOrder? Configuration.BLOCK_PERIOD: Configuration.MIN_OUT_ORDER_BLOCK_PERIOD) )</span>
<span class="nc" id="L80">                return -1;</span>


            //check vote and process vote - could be changed later
<span class="nc bnc" id="L84" title="All 2 branches missed.">            if(header.getVote() !=null) {</span>

                //check vote

<span class="nc" id="L88">                Voting changedAuthorityVoting= null;</span>

<span class="nc bnc" id="L90" title="All 2 branches missed.">                if(header.getBlockNumber()%Configuration.CHECK_POINT_BLOCK_INTERVAL==0)</span>
<span class="nc" id="L91">                    return -1;</span>

<span class="nc bnc" id="L93" title="All 2 branches missed.">                if (header.getVote().isAdd()) // return false if authorizing a validator but already in the validator list</span>
                {
<span class="nc bnc" id="L95" title="All 2 branches missed.">                    if (GeneralHelper.getIndexFromArrayList(header.getValidatorIdentifier(), tempOverallAuthorityList) != -1)</span>
<span class="nc" id="L96">                        return -1;</span>
                } else // return false if deauthorizing a validator but not in the validator list
                {
<span class="nc bnc" id="L99" title="All 2 branches missed.">                    if (GeneralHelper.getIndexFromArrayList(header.getValidatorIdentifier(), tempOverallAuthorityList) == -1)</span>
<span class="nc" id="L100">                        return -1;</span>
                }
                // this ensures that only one voting about one beneficiary to exist

<span class="nc" id="L104">                boolean isForNewVoting = true;</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">                for (Voting v : tempVotingList) // duplicate voting check</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">                    if (v.getBeneficiary().equals(header.getVote().getBeneficiary())) {</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">                        if (v.isExistingVoter(header.getValidatorIdentifier()))</span>
<span class="nc" id="L108">                            return -1;</span>

                        //process vote
<span class="nc bnc" id="L111" title="All 2 branches missed.">                        if (header.getVote().isAgree())</span>
<span class="nc" id="L112">                            v.addAgree(header.getValidatorIdentifier());</span>
                        else
<span class="nc" id="L114">                            v.addDisagree(header.getValidatorIdentifier());</span>
<span class="nc" id="L115">                        changedAuthorityVoting=v;</span>
<span class="nc" id="L116">                        isForNewVoting = false;</span>
<span class="nc" id="L117">                        break;</span>
                    }

<span class="nc bnc" id="L120" title="All 2 branches missed.">                if (isForNewVoting ) // the voting starter cannot disagree on what he started(not make sense)</span>
                {
<span class="nc bnc" id="L122" title="All 2 branches missed.">                    if(!header.getVote().isAgree())</span>
<span class="nc" id="L123">                        return -1;</span>
                    else {
                        //process vote
<span class="nc" id="L126">                        Voting newVoting = new Voting(header.getVote().getBeneficiary(), header.getVote().isAdd());</span>
<span class="nc" id="L127">                        newVoting.addAgree(header.getValidatorIdentifier());</span>
<span class="nc" id="L128">                        tempVotingList.add(newVoting);</span>
<span class="nc" id="L129">                        changedAuthorityVoting = newVoting;</span>
                    }

                }

                //process vote
<span class="nc bnc" id="L135" title="All 2 branches missed.">                if (changedAuthorityVoting.getNumAgree() &gt;= tempValidationInterval) {</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">                    if(changedAuthorityVoting.isAdd()) {</span>
<span class="nc" id="L137">                        tempOverallAuthorityList.add(changedAuthorityVoting.getBeneficiary().getIdentifier());</span>
                    }
                    else
                    {
<span class="nc" id="L141">                        tempOverallAuthorityList.remove(GeneralHelper.getIndexFromArrayList(changedAuthorityVoting.getBeneficiary().getIdentifier(),tempOverallAuthorityList));</span>
<span class="nc" id="L142">                        tempAuthorityList.remove(changedAuthorityVoting.getBeneficiary().getIdentifier());</span>
                    }
<span class="nc" id="L144">                    tempVotingList.remove(changedAuthorityVoting);</span>
                }
<span class="nc bnc" id="L146" title="All 2 branches missed.">                else if(changedAuthorityVoting.getNumDisagree() &gt; tempOverallAuthorityList.size()- tempValidationInterval)</span>
                {
<span class="nc" id="L148">                    tempVotingList.remove(changedAuthorityVoting);</span>
                }

            }

<span class="nc" id="L153">            tempTotalScore+=expectedScore;</span>
<span class="nc" id="L154">            prevBlockTimeStemp= header.getTimestamp();</span>
        }

<span class="nc" id="L157">        return tempTotalScore;</span>

    }

    public static boolean checkBlock(Block block) throws BlockChainObjectParsingException, IOException, FileCorruptionException {
<span class="nc" id="L162">        ArrayList&lt;byte[]&gt; tempOverallAuthorityList = AuthorityInfoManager.loadOverall(block.getHeader().getPrevHash());</span>
<span class="nc" id="L163">        AuthorityInfoForInternal validatorInfoForInternal = AuthorityInfoManager.load(block.getHeader().getPrevHash(), block.getHeader().getValidatorIdentifier());</span>
<span class="nc" id="L164">        StateInfo prevBlockStateInfo =StateInfoManager.load(block.getHeader().getPrevHash());</span>
<span class="nc" id="L165">        byte[] prevBlockHash = block.getHeader().getPrevHash();</span>

<span class="nc bnc" id="L167" title="All 4 branches missed.">        if(prevBlockStateInfo==null||validatorInfoForInternal==null)</span>
<span class="nc" id="L168">            return false;</span>
        try {
<span class="nc bnc" id="L170" title="All 2 branches missed.">            if(!SecurityHelper.verifyRawECDSASignatureWithContent(validatorInfoForInternal.getAuthorityInfo().getPublicKey(), block.getHeader().getSignatureCoverage(),block.getHeader().getValidatorSignature(), Configuration.BLOCKCHAIN_HASH_ALGORITHM,Configuration.ELIPTIC_CURVE))</span>
<span class="nc" id="L171">                return false;</span>
<span class="nc" id="L172">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L173">            e.printStackTrace();</span>
<span class="nc" id="L174">        }</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">        if(!Arrays.equals(block.getHeader().getContentHash(), block.getContent().calculateHash()))</span>
<span class="nc" id="L176">            return false;</span>

<span class="nc bnc" id="L178" title="All 2 branches missed.">        if(!validatorInfoForInternal.canSign(block.getHeader().getBlockNumber(), prevBlockStateInfo.getTotalAuthorities()))</span>
<span class="nc" id="L179">            return false;</span>

<span class="nc" id="L181">        boolean isInOrder =AuthorityInfoForInternal.isInOrder(block.getHeader().getBlockNumber(), prevBlockStateInfo.getTotalAuthorities(), GeneralHelper.getIndexFromArrayList(block.getHeader().getValidatorIdentifier(),tempOverallAuthorityList));</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">        int expectedScore = isInOrder?2:1;</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">        if(expectedScore!= block.getHeader().getScore())</span>
<span class="nc" id="L184">            return false;</span>

<span class="nc" id="L186">        BlockHeader prevBlockHeader = BlockManager.loadBlockHeader(block.getHeader().getPrevHash());</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">        if(prevBlockHeader==null)</span>
<span class="nc" id="L188">            return false;</span>

<span class="nc bnc" id="L190" title="All 4 branches missed.">        if(block.getHeader().getTimestamp() - prevBlockHeader.getTimestamp() &lt;(isInOrder? Configuration.BLOCK_PERIOD: Configuration.MIN_OUT_ORDER_BLOCK_PERIOD) )</span>
<span class="nc" id="L191">            return false;</span>

<span class="nc bnc" id="L193" title="All 2 branches missed.">        if(block.getHeader().getVote() !=null) {</span>

<span class="nc bnc" id="L195" title="All 2 branches missed.">            if(block.getHeader().getBlockNumber()%Configuration.CHECK_POINT_BLOCK_INTERVAL==0) // check point cannot have vote</span>
<span class="nc" id="L196">                return false;</span>

<span class="nc bnc" id="L198" title="All 2 branches missed.">            if (!checkVote(block.getHeader().getPrevHash(), validatorInfoForInternal.getAuthorityInfo(), block.getHeader().getVote()))</span>
<span class="nc" id="L199">                return false;</span>
        }

        //*****header check end


        //*****content check start

        //want to authorize, but already authorized
<span class="nc bnc" id="L208" title="All 2 branches missed.">        if(block.getContent().getMedicalOrgAuthorizationList() !=null) {</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">            if(block.getContent().getMedicalOrgAuthorizationList().length&gt;Configuration.MAX_AUTHORIZATION)</span>
<span class="nc" id="L210">                return false;</span>

<span class="nc" id="L212">            Set&lt;MedicalOrgInfo&gt; set = new HashSet&lt;&gt;(); //for duplicate check</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">            for (MedicalOrgInfo medicalOrgInfo : block.getContent().getMedicalOrgAuthorizationList()) {</span>

<span class="nc bnc" id="L215" title="All 2 branches missed.">                if(medicalOrgInfo.getName().length()&gt;Configuration.MAX_NAME_LENGTH)</span>
<span class="nc" id="L216">                    return false;</span>

<span class="nc bnc" id="L218" title="All 2 branches missed.">                if (MedicalOrgInfoManager.load(prevBlockHash, medicalOrgInfo.getIdentifier()) != null)</span>
<span class="nc" id="L219">                    return false;</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">                if(MedicalOrgInfoManager.isRevoked(prevBlockHash,medicalOrgInfo.getIdentifier()))</span>
<span class="nc" id="L221">                    return false;</span>

<span class="nc bnc" id="L223" title="All 2 branches missed.">                if(set.contains(medicalOrgInfo))</span>
<span class="nc" id="L224">                    return false;</span>
                else
                {
<span class="nc" id="L227">                    set.add(medicalOrgInfo);</span>
                }
            }
        }

<span class="nc bnc" id="L232" title="All 2 branches missed.">        if(block.getContent().getMedicalOrgRevocationList() !=null) {</span>

<span class="nc bnc" id="L234" title="All 2 branches missed.">            if(block.getContent().getMedicalOrgRevocationList().length&gt;Configuration.MAX_REVOCATION)</span>
<span class="nc" id="L235">                return false;</span>

<span class="nc" id="L237">            SortedSet&lt;byte[]&gt; set = new TreeSet&lt;&gt;(new GeneralHelper.byteArrayComparator()); //for duplicate check</span>

            //want to addToRevocationList but not issued such key, invalid
<span class="nc bnc" id="L240" title="All 2 branches missed.">            for (byte[] revokedIdentifier : block.getContent().getMedicalOrgRevocationList()) {</span>
<span class="nc" id="L241">                MedicalOrgInfoForInternal medicalOrgInfoForInternal = MedicalOrgInfoManager.load(prevBlockHash, revokedIdentifier);</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">                if (medicalOrgInfoForInternal == null)</span>
<span class="nc" id="L243">                    return false;</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">                if (!Arrays.equals(medicalOrgInfoForInternal.getAuthorityIdentifier(), block.getHeader().getValidatorIdentifier()))</span>
<span class="nc" id="L245">                    return false;</span>

<span class="nc bnc" id="L247" title="All 2 branches missed.">                if(set.contains(revokedIdentifier))</span>
<span class="nc" id="L248">                    return false;</span>
                else
                {
<span class="nc" id="L251">                    set.add(revokedIdentifier);</span>
                }
            }
        }

<span class="nc bnc" id="L256" title="All 2 branches missed.">        if(block.getContent().getPatientInfoList() !=null) {</span>

<span class="nc bnc" id="L258" title="All 2 branches missed.">            if(block.getContent().getPatientInfoList().length&gt;Configuration.MAX_PATIENT_INFO)</span>
<span class="nc" id="L259">                return false;</span>

<span class="nc" id="L261">            Set&lt;PatientInfo&gt; set = new HashSet&lt;&gt;(); //for duplicate check</span>

<span class="nc bnc" id="L263" title="All 2 branches missed.">            for (PatientInfo patientInfo : block.getContent().getPatientInfoList()) {</span>

<span class="nc bnc" id="L265" title="All 2 branches missed.">                if(!patientInfo.verify())</span>
<span class="nc" id="L266">                    return false;</span>

<span class="nc bnc" id="L268" title="All 2 branches missed.">                if (PatientInfoManager.patientInfoExists(block.getHeader().getPrevHash(), patientInfo.getPatientIdentifier(), patientInfo.calculateInfoHash())) {</span>
<span class="nc" id="L269">                    return false;</span>

                }

<span class="nc bnc" id="L273" title="All 2 branches missed.">                if(set.contains(patientInfo))</span>
<span class="nc" id="L274">                    return false;</span>
                else
                {
<span class="nc" id="L277">                    set.add(patientInfo);</span>
                }

            }
        }


<span class="nc bnc" id="L284" title="All 2 branches missed.">        if(block.getContent().getTransactions() !=null) {</span>

<span class="nc bnc" id="L286" title="All 2 branches missed.">            if(block.getContent().getTransactions().length&gt;Configuration.MAX_RECORD)</span>
<span class="nc" id="L287">                return false;</span>

<span class="nc" id="L289">            Set&lt;Transaction&gt; set = new HashSet&lt;&gt;(); //for duplicate check</span>

<span class="nc bnc" id="L291" title="All 2 branches missed.">            for (Transaction transaction : block.getContent().getTransactions()) {</span>
<span class="nc" id="L292">                MedicalOrgInfoForInternal medicalOrgInfoForInternal = MedicalOrgInfoManager.load(prevBlockHash, transaction.getMedicalOrgIdentifier());</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">                if (medicalOrgInfoForInternal == null)</span>
<span class="nc" id="L294">                    return false;</span>

<span class="nc bnc" id="L296" title="All 2 branches missed.">                if (!TransactionManager.isTransactionUnique(block.getHeader().getPrevHash(), transaction.calculateHash(), transaction.getPatientIdentifier()))</span>
<span class="nc" id="L297">                    return false;</span>

<span class="nc bnc" id="L299" title="All 2 branches missed.">                if(set.contains(transaction))</span>
<span class="nc" id="L300">                    return false;</span>
                else
                {
<span class="nc" id="L303">                    set.add(transaction);</span>
                }

<span class="nc" id="L306">                PatientInfo patientInfo = PatientInfoManager.load(block.getHeader().getPrevHash(), transaction.getPatientIdentifier());</span>

<span class="nc bnc" id="L308" title="All 2 branches missed.">                if (!transaction.verify(patientInfo.getPublicKey(), medicalOrgInfoForInternal.getMedicalOrgInfo().getPublicKey()))</span>
<span class="nc" id="L309">                    return false;</span>
            }
        }

        //*****content check end

<span class="nc" id="L315">        return true;</span>
    }

    public static boolean checkVote(byte[] prevBlockHash, AuthorityInfo voter,Vote vote) throws BlockChainObjectParsingException, IOException {

<span class="nc bnc" id="L320" title="All 2 branches missed.">        if(vote.getBeneficiary().getName().length()&gt;Configuration.MAX_NAME_LENGTH)</span>
<span class="nc" id="L321">            return false;</span>

<span class="nc" id="L323">        byte[] beneficiaryIdentifier = vote.getBeneficiary().getIdentifier();</span>
<span class="nc" id="L324">        AuthorityInfoForInternal validatorInfoForInternal = AuthorityInfoManager.load(prevBlockHash,beneficiaryIdentifier);</span>
<span class="nc" id="L325">        ArrayList&lt;Voting&gt; prevVotingList = VotingManager.load(prevBlockHash);</span>

<span class="nc bnc" id="L327" title="All 2 branches missed.">        if (vote.isAdd()) // return false if authorizing a validator but already in the validator list</span>
        {
<span class="nc bnc" id="L329" title="All 2 branches missed.">            if(validatorInfoForInternal != null) // even if untrusted</span>
<span class="nc" id="L330">                return false;</span>
        } else // return false if deauthorizing a validator but not in the validator list
        {
<span class="nc bnc" id="L333" title="All 4 branches missed.">            if(validatorInfoForInternal == null||validatorInfoForInternal.getUntrustedBlock()!=null) // if not exists ( never trusted or untrusted)</span>
<span class="nc" id="L334">                return false;</span>
        }
        // this ensures that only one voting about one beneficiary to exist

<span class="nc" id="L338">        boolean isForNewVoting = true;</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">        for (Voting v : prevVotingList) // duplicate voting check</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">            if (v.getBeneficiary().equals(vote.getBeneficiary())) {</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">                if (v.isExistingVoter(voter.getIdentifier()))</span>
<span class="nc" id="L342">                    return false;</span>
<span class="nc" id="L343">                isForNewVoting = false;</span>
            }

<span class="nc bnc" id="L346" title="All 4 branches missed.">        return !isForNewVoting || vote.isAgree();</span>

    }


    // block should be checked beforehand
    public static int storeBlock(Block block) throws IOException, BlockChainObjectParsingException {
<span class="nc" id="L353">        byte[] blockHash = block.calculateHash();</span>
<span class="nc" id="L354">        StateInfo prevBlockStateInfo=StateInfoManager.load(block.getHeader().getPrevHash());</span>

<span class="nc" id="L356">        BlockManager.saveBlock(block);</span>

<span class="nc" id="L358">        boolean authorityListChanged = false;</span>
<span class="nc" id="L359">        boolean votingListChanged =false;</span>


<span class="nc bnc" id="L362" title="All 2 branches missed.">        if(block.getContent().getMedicalOrgAuthorizationList() !=null)</span>
<span class="nc" id="L363">            processAuthorization(blockHash, block.getHeader().getValidatorIdentifier(), block.getContent().getMedicalOrgAuthorizationList());</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">        if(block.getContent().getMedicalOrgRevocationList() !=null)</span>
<span class="nc" id="L365">            processRevocation(blockHash, block.getContent().getMedicalOrgRevocationList());</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">        if(block.getContent().getPatientInfoList() !=null)</span>
<span class="nc" id="L367">            processRegistration(blockHash, block.getContent().getPatientInfoList());</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">        if(block.getContent().getTransactions() !=null)</span>
<span class="nc" id="L369">            processTransactions(blockHash, block.getContent().getTransactions());</span>


<span class="nc bnc" id="L372" title="All 2 branches missed.">        if(block.getHeader().getVote() !=null) {</span>
<span class="nc" id="L373">            votingListChanged=true;</span>
<span class="nc" id="L374">            authorityListChanged = processVote(blockHash, block.getHeader().getPrevHash(), block.getHeader().getValidatorIdentifier(),</span>
<span class="nc" id="L375">                    block.getHeader().getVote(), prevBlockStateInfo.getTotalAuthorities());</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">        } else if(block.getHeader().getBlockNumber()%Configuration.CHECK_POINT_BLOCK_INTERVAL==0)</span>
        {
<span class="nc" id="L378">            votingListChanged=true;</span>
<span class="nc" id="L379">            VotingManager.saveCheckPoint(blockHash);</span>
        }



<span class="nc" id="L384">        StateInfoManager.save(block,authorityListChanged,votingListChanged);</span>
<span class="nc" id="L385">        ChainInfoManager.save(block);</span>


<span class="nc" id="L388">        int newTotalScore = prevBlockStateInfo.getTotalScore() + block.getHeader().getScore();</span>

<span class="nc" id="L390">        Status bestChainStatus = BestChainInfoManager.load();</span>

<span class="nc bnc" id="L392" title="All 2 branches missed.">        if(newTotalScore&gt; bestChainStatus.getTotalScore())</span>
        {
<span class="nc" id="L394">            changeBestChain(blockHash);</span>
<span class="nc" id="L395">            BestChainInfoManager.save(new Status(newTotalScore, blockHash));</span>
        }

<span class="nc" id="L398">        return newTotalScore;</span>

    }


    private static void processAuthorization(byte[] blockHash, byte[] authorityIdentifier, MedicalOrgInfo[] medicalOrgAuthorizationList) throws IOException {
<span class="nc bnc" id="L404" title="All 2 branches missed.">        for(MedicalOrgInfo medicalOrgInfo:medicalOrgAuthorizationList)</span>
<span class="nc" id="L405">            MedicalOrgInfoManager.authorize(blockHash,medicalOrgInfo,authorityIdentifier);</span>
<span class="nc" id="L406">    }</span>

    private static void processRevocation(byte[] blockHash, byte[][] medicalOrgRevocationList) throws IOException {
<span class="nc bnc" id="L409" title="All 2 branches missed.">        for(byte[] revokedIdentifier:medicalOrgRevocationList)</span>
<span class="nc" id="L410">            MedicalOrgInfoManager.revoke(blockHash,revokedIdentifier);</span>
<span class="nc" id="L411">    }</span>

    private static void processRegistration(byte[] blockHash, PatientInfo[] patientRegistrationList) throws IOException {
<span class="nc bnc" id="L414" title="All 2 branches missed.">        for(PatientInfo patientInfo :patientRegistrationList)</span>
<span class="nc" id="L415">            PatientInfoManager.save(blockHash, patientInfo);</span>
<span class="nc" id="L416">    }</span>

    private static void processTransactions(byte[] blockHash, Transaction[] transactions) throws BlockChainObjectParsingException, IOException {
<span class="nc" id="L419">        SortedMap&lt;byte[], String&gt; tempMedicalOrgNames=new TreeMap&lt;&gt;(new GeneralHelper.byteArrayComparator());</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">        for(Transaction transaction: transactions) {</span>

            String name;
<span class="nc bnc" id="L423" title="All 2 branches missed.">            if (!tempMedicalOrgNames.containsKey(transaction.getMedicalOrgIdentifier()))</span>
            {
<span class="nc" id="L425">                name=MedicalOrgInfoManager.loadName(blockHash,transaction.getMedicalOrgIdentifier());</span>
<span class="nc" id="L426">                tempMedicalOrgNames.put(transaction.getMedicalOrgIdentifier(),name);</span>
            }
            else
            {
<span class="nc" id="L430">                name=tempMedicalOrgNames.get(transaction.getMedicalOrgIdentifier());</span>
            }
<span class="nc" id="L432">            TransactionManager.save(blockHash, transaction,name);</span>
        }
<span class="nc" id="L434">    }</span>

    // return true if the vote is processed( more than half agreed )
    // Also, store the changed voting list
    private static boolean processVote(byte[] blockHash, byte[] prevBlockHash,byte[] voterIdentifier, Vote vote, int prevTotalAuthorities) throws IOException, BlockChainObjectParsingException {

<span class="nc" id="L440">        int validationInterval= (prevTotalAuthorities/2) +1;</span>
<span class="nc" id="L441">        ArrayList&lt;Voting&gt; votingList =VotingManager.load(prevBlockHash);</span>

<span class="nc" id="L443">        boolean isForNewVoting = true;</span>
<span class="nc" id="L444">        Voting changedAuthorityVoting= null;</span>

<span class="nc bnc" id="L446" title="All 2 branches missed.">        for (Voting voting : votingList) // if voting about the beneficiary already exists cast a vote</span>
        {
<span class="nc bnc" id="L448" title="All 2 branches missed.">            if (voting.getBeneficiary().equals(vote.getBeneficiary())) {</span>
<span class="nc" id="L449">                isForNewVoting=false;</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">                if (vote.isAgree())</span>
<span class="nc" id="L451">                    voting.addAgree(voterIdentifier);</span>
                else
<span class="nc" id="L453">                    voting.addDisagree(voterIdentifier);</span>
<span class="nc" id="L454">                changedAuthorityVoting=voting;</span>
<span class="nc" id="L455">                break;</span>
            }

<span class="nc" id="L458">        }</span>

        // create new voting
<span class="nc bnc" id="L461" title="All 2 branches missed.">        if(isForNewVoting) {</span>
<span class="nc" id="L462">            Voting newVoting = new Voting(vote.getBeneficiary(), vote.isAdd());</span>
<span class="nc" id="L463">            newVoting.addAgree(voterIdentifier);</span>
<span class="nc" id="L464">            votingList.add(newVoting);</span>
<span class="nc" id="L465">            changedAuthorityVoting=newVoting;</span>

        }


<span class="nc bnc" id="L470" title="All 2 branches missed.">        boolean isVotingProcessed= changedAuthorityVoting.getNumAgree() &gt;= validationInterval;</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">        if (isVotingProcessed) {</span>
<span class="nc" id="L472">            votingList.remove(changedAuthorityVoting);</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">            if(changedAuthorityVoting.isAdd()) {</span>
<span class="nc" id="L474">                AuthorityInfoManager.trust(blockHash, prevBlockHash, vote.getBeneficiary());</span>
            }
            else
            {
<span class="nc" id="L478">                AuthorityInfoManager.untrust(blockHash,prevBlockHash, vote.getBeneficiary());</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">                for(Voting voting: votingList)</span>
                {
<span class="nc" id="L481">                    voting.removeDisagree(vote.getBeneficiary().getIdentifier());</span>
<span class="nc" id="L482">                    voting.removeAgree(vote.getBeneficiary().getIdentifier());</span>
<span class="nc" id="L483">                }</span>
            }
        }
<span class="nc bnc" id="L486" title="All 2 branches missed.">        else if(changedAuthorityVoting.getNumDisagree() &gt; prevTotalAuthorities-validationInterval)</span>
        {
<span class="nc" id="L488">            votingList.remove(changedAuthorityVoting);</span>
        }

<span class="nc" id="L491">        VotingManager.save(blockHash,votingList);</span>

<span class="nc" id="L493">        return isVotingProcessed;</span>
    }

    public static boolean hasBlock(byte[] blockHash) throws BlockChainObjectParsingException, IOException {
<span class="nc bnc" id="L497" title="All 2 branches missed.">        return BlockManager.loadBlockHeader(blockHash)!=null;</span>
    }

    public static void changeBestChain(byte[] newHeadBlockHash) throws IOException, BlockChainObjectParsingException {

<span class="nc" id="L502">        byte[] processingBlockHash= newHeadBlockHash;</span>
<span class="nc" id="L503">        byte[] nextBlockhash = null;</span>


            while(true) {
<span class="nc" id="L507">                ChainInfo processingBlockChainInfoBeforeChange =ChainInfoManager.load(processingBlockHash);</span>
<span class="nc" id="L508">                boolean fromPrevMainChain= processingBlockChainInfoBeforeChange.isBestChain();</span>
<span class="nc" id="L509">                ChainInfoManager.changeChainInfo(processingBlockHash,true,nextBlockhash);</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">                if(fromPrevMainChain)</span>
<span class="nc" id="L511">                    break;</span>

<span class="nc" id="L513">                nextBlockhash=processingBlockHash;</span>
<span class="nc" id="L514">                processingBlockHash= processingBlockChainInfoBeforeChange.getPrevBlockHash();</span>
<span class="nc" id="L515">            }</span>

<span class="nc" id="L517">            byte[] targetBlockHash = processingBlockHash;</span>
<span class="nc" id="L518">            processingBlockHash= BestChainInfoManager.load().getLatestBlockHash();</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">            while(!Arrays.equals(targetBlockHash,processingBlockHash))</span>
            {
<span class="nc" id="L521">                ChainInfo processingBlockChainInfoBeforeChange =ChainInfoManager.load(processingBlockHash);</span>
<span class="nc" id="L522">                ChainInfoManager.changeChainInfo(processingBlockHash,false,null);</span>

<span class="nc" id="L524">                processingBlockHash= processingBlockChainInfoBeforeChange.getPrevBlockHash();</span>
<span class="nc" id="L525">            }</span>

<span class="nc" id="L527">    }</span>

    //checks if the checking block is behind the baseblock (or the same block) and in the same chain
    //use the main chain for effective checking( using the fact that branches won't be too long from the main chain)
    public static boolean isThisBlockOnTheChain(byte[] baseBlockHash, byte[] checkingBlockHash) throws BlockChainObjectParsingException, IOException {

<span class="nc bnc" id="L533" title="All 2 branches missed.">        if(Arrays.equals(baseBlockHash,checkingBlockHash))</span>
<span class="nc" id="L534">            return true;</span>

<span class="nc" id="L536">        ChainInfo baseBlockChainInfo = ChainInfoManager.load(baseBlockHash);</span>
<span class="nc" id="L537">        ChainInfo checkingBlockChainInfo = ChainInfoManager.load(checkingBlockHash);</span>

<span class="nc" id="L539">        boolean isBaseBlockMainChain = baseBlockChainInfo.isBestChain();</span>
<span class="nc" id="L540">        boolean isCheckingBlockInMainChain = checkingBlockChainInfo.isBestChain();</span>

<span class="nc" id="L542">        int baseBlockNumber = BlockManager.loadBlockHeader(baseBlockHash).getBlockNumber();</span>
<span class="nc" id="L543">        int checkingBlockNumber = BlockManager.loadBlockHeader(checkingBlockHash).getBlockNumber();</span>


        boolean result;

<span class="nc bnc" id="L548" title="All 2 branches missed.">        if(baseBlockNumber&lt;=checkingBlockNumber) // same block number but different hash obviously different chain</span>
<span class="nc" id="L549">            result= false;</span>
<span class="nc bnc" id="L550" title="All 4 branches missed.">        else if(isBaseBlockMainChain &amp;&amp; isCheckingBlockInMainChain)</span>
<span class="nc" id="L551">            result= true;</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">        else if(isBaseBlockMainChain)</span>
<span class="nc" id="L553">            result= false;</span>
        else
        {
<span class="nc" id="L556">            ChainInfo processingBlockChainInfo = baseBlockChainInfo;</span>
<span class="nc" id="L557">            byte[] processingBlockHash = baseBlockHash;</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">            while(!processingBlockChainInfo.isBestChain())</span>
            {
<span class="nc" id="L560">                processingBlockHash = processingBlockChainInfo.getPrevBlockHash();</span>
<span class="nc" id="L561">                processingBlockChainInfo = ChainInfoManager.load(processingBlockChainInfo.getPrevBlockHash());</span>
            }

<span class="nc" id="L564">            BlockHeader firstInChainBaseBlockHeader = BlockManager.loadBlockHeader(processingBlockHash);</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">            if(isCheckingBlockInMainChain) {</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">                result= firstInChainBaseBlockHeader.getBlockNumber() &gt;= checkingBlockNumber;</span>
            }
            else
            {
<span class="nc" id="L570">                ChainInfo processingCheckingBlockChainInfo = checkingBlockChainInfo;</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">                while(processingCheckingBlockChainInfo.isBestChain())</span>
                {
<span class="nc" id="L573">                    processingCheckingBlockChainInfo = ChainInfoManager.load(processingCheckingBlockChainInfo.getPrevBlockHash());</span>
                }

<span class="nc" id="L576">                BlockHeader firstInChainCheckingBlockHeader = BlockManager.loadBlockHeader(processingCheckingBlockChainInfo.getPrevBlockHash());</span>

<span class="nc bnc" id="L578" title="All 2 branches missed.">                result= firstInChainBaseBlockHeader.getBlockNumber() &gt;= firstInChainCheckingBlockHeader.getBlockNumber();</span>
            }
        }

<span class="nc" id="L582">        return result;</span>


    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>